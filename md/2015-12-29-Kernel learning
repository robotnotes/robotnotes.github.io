Kernel learning
======
Linux 对线程的实现是：内核并不区分线程和其他的一般进程。对于内核来说，所有的进程都一样——只不过是其中的一些共享资源而已

#### 内核开发的特点
* 既不能访问C库，也不能访问标准C头文件
* 必须使用GNU C
* 缺乏像用户空间那样的保护机制
* 难以进行浮点运算
* 内核给每个进程只有一个很小的定长堆栈
* 由于内核支持异步中断、抢占和SMP，因此必须时刻注意同步和并发
* 要考虑可移植性

#### 内核头文件
* 基本的头文件位于 include 目录，如 `<linux/inotify.h>` 对应内核源码树的 `include/linux/inotify.h`
* 体系结构相关的头文件位于 `arch/<architecture>/include/asm` 下，内核代码通过以`asm/` 为前缀包含这些头文件 `<asm/ioctl.h>`


`printk` 中可以在 *pattern* 前面加优先级，如 `KERN_ERR "this is an error!"`

#### 内核中用到C扩展部分
1. 内联函数
	`static inline void wolf(unsigned long tail_size)`，把对时间要求较高，本身长度比较短的函数定义成内联，如果一个函数比较大，会被反复调用，且没有特别的时间上的限制，不赞成定义成内联函数。
	一般在头文件中定义，为了类型安全和易读性，优先使用内联函数而不是宏。

2. 内联汇编
```
asm volatile ("rdtsc": "=a" (low), "=d" (high))
```
含义是执行x86处理器的 `rdtsc` 指令，返回时间戳`tsc`寄存器的值，其中low和high表示返回的64位时间戳的低32位和高32位

3. 分支声明
	gcc内建了一条优化指令，在一个条件里经常出现或者很少出现，可以优化分支
	下面表示 error 绝大多数时间都是0

	```
	if (unlikely(error)) {
	...
	}
	```

	下面表示 success 通常不都是0
	```
	if (likely(success)) {
	...
	}
	```
	

内核里做了非法内存访问会 oops，内存里没有分页，用掉多少，物理内存就少了多少

内核中浮点数问题：它本身不支持trap，如果非要用，要手工保存和恢复浮点寄存器，所以，别用了。

